<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Dwny Blog]]></title><description><![CDATA[A blog written by dwny]]></description><link>https://dwnyh.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 28 Mar 2020 08:08:02 GMT</lastBuildDate><item><title><![CDATA[About Dawoon]]></title><description><![CDATA[Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae…]]></description><link>https://dwnyh.github.io/aboutMe/</link><guid isPermaLink="false">https://dwnyh.github.io/aboutMe/</guid><content:encoded>&lt;p&gt;Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/image-2.jpg&quot; alt=&quot;Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi.&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus&lt;/p&gt;</content:encoded></item><item><title><![CDATA[호이스팅과 TDZ]]></title><description><![CDATA[자바스크립트의 호이스팅(Hoisting…]]></description><link>https://dwnyh.github.ioposts/TIL/hoist-and-tdz/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/hoist-and-tdz/</guid><pubDate>Fri, 22 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트의 호이스팅(Hoisting)의 어원 &lt;code class=&quot;language-text&quot;&gt;hoist&lt;/code&gt;의 뜻을 찾아보면 다음과 같다.&lt;br&gt;
&lt;strong&gt;“소형의 감아올리는 장치. 공장 내의 재료 운반·조립에 사용하며, 들보 위에서 이동시킴. 구동 방식에 따라 공기 호이스트·전기 호이스트 등으로 나누어짐.”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;구글 이미지를 검색해보면 작은 도르래 같이 보이는 것들이 많이 보이는데, 위의 정의와 같이 운반시에 끌어올리는 역할을 한다고 한다. 따라서 이 어원에서 비롯된 자바스크립트에서 쓰이는 호이스트의 개념 역시, 변수 또는 함수가 정의된 후 그 선언이 끌어올려짐을 의미한다. &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;과 같은 변수 선언문이나 &lt;code class=&quot;language-text&quot;&gt;function(){}&lt;/code&gt;과 같이 함수표현식으로 작성된 함수의 선언이 스코프 내의 상위로 끌어올려져서 이로 정의된 변수나 함수가 선언 전에 호출이 되어도 실행이 가능한 것이다.&lt;/p&gt;
&lt;p&gt;이와 더불어 &lt;code class=&quot;language-text&quot;&gt;TDZ&lt;/code&gt; 개념도 함께 설명할 수 있는데, &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;로 정의된 변수는 선언하면 호이스팅과 동시에 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 값으로 초기화 되는 반면, &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;는 호이스팅은 가능해서 위로 끌어올려지지만 초기값이 할당되지 않기 때문에 할당되기 전에 선언된 변수를 사용하게 되면 &lt;code class=&quot;language-text&quot;&gt;Reference Error&lt;/code&gt;가 발생하게 된다. 따라서 끌어올려졌지만 변수에 값이 할당되기 전까지는 사용이 불가하므로 이 구역을 &lt;code class=&quot;language-text&quot;&gt;TDZ(Temporal Dead Zone)&lt;/code&gt;이라고 일컫는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;TDZ&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; answer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;I like &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;favoriteFruit&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Reference Error!&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; favoriteFruit &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지가 원래 내가 알고 있던 내용이었는데, You Don’t Know JS 책을 읽던 도중 호이스팅 개념이 나와서 확인차 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Glossary/Hoisting&quot;&gt;mdn 문서&lt;/a&gt;를 한번 확인하였는데 새로운 사실을 알게되었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;호이스팅을 변수 및 함수 선언이 물리적으로 작성한 코드의 상단으로 옮겨지는 것으로 가르치지만  
실제로는 그렇지 않습니다. 변수 및 함수 선언은 컴파일 단계에서 메모리에 저장되지만, 코드에서 입력한 
위치와 정확히 일치한 곳에 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위에 내가 작성했던 예제와 같이 나 역시 호이스팅은 물리적으로 위로 끌어올려지는 개념이며, 그래서 TDZ라는 구역이 물리적으로 할당이 되는 것이라고 생각했는데, 그게 아니었다! 컴파일단계에서 선언이 저장되는 것이고 런타임에서 할당부분이 일어나기 전까지 TDZ가 형성되는 것이므로 오히려 물리적이라기보다 시점의 차이라고 볼 수 있는 것이다. 흥미롭당..🧐&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Optional Chaining]]></title><description><![CDATA[이 포스팅은 가드연산자보다 을 알게된 부분을 작성하고 싶어 쓰게 되었다. 어제 You Don’t Know JS 네번째 모임에서 가드연산자 부분에 대한 이야기를 다루는데 어떤분이 이 가드연산자를 편하게 쓸 수 있는 optional chaining…]]></description><link>https://dwnyh.github.ioposts/TIL/guard-operator/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/guard-operator/</guid><pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 포스팅은 가드연산자보다 &lt;code class=&quot;language-text&quot;&gt;Ecma TC39 propsal&lt;/code&gt;을 알게된 부분을 작성하고 싶어 쓰게 되었다. 어제 You Don’t Know JS 네번째 모임에서 가드연산자 부분에 대한 이야기를 다루는데 어떤분이 이 가드연산자를 편하게 쓸 수 있는 &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt;에 대하여 말씀해주셨다.&lt;/p&gt;
&lt;p&gt;간단하게 말하자면, 가드연산자는 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;의 첫번째 피연산자의 평가 결과가 truthy일 때 두 번째 연산자를 선택하는 것인데, 주로 &lt;code class=&quot;language-text&quot;&gt;object &amp;amp;&amp;amp; object.property&lt;/code&gt; 이런식으로 많이 쓰이며, 나도 실제로 많이 사용하고 있는 연산자였다. &lt;/p&gt;
&lt;p&gt;그런데 현재 tc39의 proposal로 등록되어 stage3까지 가서 자바스크립트 문법에 도입될 확률이 높은 &lt;code class=&quot;language-text&quot;&gt;Optional Chaining&lt;/code&gt;이라는 것을 사용하게 되면 위의 가드연산자로 표현한 구문을 더 간결하게 표현할 수 있다는 것이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Guard Operator 이용&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; object &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;property&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Optional Chaining 이용&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; object&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;property&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;간결하게 표현될 수 있다는 사실도 놀라웠지만, 사실 이런 동향을 살필 수 있다는 사실을 처음 알게되어 무척 흥미로웠다. 위의 Optional Chaining 설명에는 &lt;code class=&quot;language-text&quot;&gt;Nullish coalescing operator&lt;/code&gt; 라는 또 다른 proposal 연산자도 함께 설명하는 구문이 있어서 다른 proposal도 확인해 볼 수 있었는데, 이 역시 stage3에 들어가 도입될 확률이 높은 문법이다.&lt;/p&gt;
&lt;p&gt;이는 다음 예제와 같이 || 연산자를 이용해 앞에 값이 falsy일 경우에 두번째 피연산자값을 이용하게 하는 방식을 보완하기 위한 방법이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; headerText &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;headerText &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Hello, world!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; animationDuration &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;animationDuration &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; showSplashScreen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;showSplashScreen &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OR 연산자의 좌측 값이 null 또는 undefined임을 가정하며 위와 같은 구문들을 작성하지만, 좌측의 값이 Boolean타입으로 변환된 후 측정되기 때문에 의도된 값이 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;, 0, false&lt;/code&gt; 와 같이 falsy일 경우에 해당 값이 나오지 않고 연산자 뒤의 값이 리턴될 수가 있다. 이와 같은 예기치 못한 상황을 막기 위해 고안된 것이 &lt;code class=&quot;language-text&quot;&gt;Nullish coalescing operator&lt;/code&gt;인 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; headerText &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;headerText &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Hello, world!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; animationDuration &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;animationDuration &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; showSplashScreen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settings&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;showSplashScreen &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OR 연산자 대신에 ?? 라는 nullish coalescing 연산자를 이용하여 앞의 값이 null 또는 undefined일 경우에만 연산자 우측값을 리턴하도록 하게 해주는 방식이다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ECMA TC39&lt;/code&gt;에 가보면 정말 수많은 proposal들이 있다. 아직은 자바스크립트밖에 안써봤고 불편함을 느끼기보다는 주어진 것 내에서 잘해야겠다는 생각만 가지고 있었는데 이렇게 더 나은방법을 고안하고 제기해주는 일들이 일어난다는 것이 무척 흥미로웠다. 아직은 기존 문법을 더 정확히 이해하는 데에 시간을 더 많이 쓰지만 시간이 날 때 틈틈히 최신 동향도 살펴보아야겠다는 생각이 들었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트에서의 비교('==', '>')]]></title><description><![CDATA[…]]></description><link>https://dwnyh.github.ioposts/TIL/equality-comparison/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/equality-comparison/</guid><pubDate>Sat, 16 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;실제 코드에서는 주로 정확한 비교를 위해(타입비교까지) === 비교만 사용하지 == 비교는 잘 사용하지 않았고, ==는 값만 비교한다는 사실은 알았지만 강제변환을 통해 값만 비교한다는 사실은 알지 못했다. 실제로 잘 쓰는 일은 많이 없을 것 같지만 &lt;strong&gt;You don’t know JS 4장 강제변환&lt;/strong&gt; 뒷부분에 여러 타입별로 추상화 동등비교(’==‘)하는 예제가 있는데 규칙에 따라 맞춰보는 과정이 꽤 흥미로웠어서 읽어본 김에 한번 정리해보려고 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 문자열과 숫자를 비교하면 문자열은 숫자로 강제변환 된다.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 불리언과 다른 타입을 비교하면 둘다 숫자로 강제변환 된다.&lt;/strong&gt;&lt;br&gt;
=&gt; &lt;code class=&quot;language-text&quot;&gt;&amp;quot;42&amp;quot; == true&lt;/code&gt;를 하게 되면 “42”값이 truthy인 것과 관련없이 숫자 42로 변환되고 우측 true도 숫자 1로 강제변환된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) null과 undefined를 비교하면 서로에게 타입을 맞춘다.&lt;/strong&gt;&lt;br&gt;
=&gt; &lt;code class=&quot;language-text&quot;&gt;a === undefined ||  a === null&lt;/code&gt;보다 &lt;code class=&quot;language-text&quot;&gt;a == null&lt;/code&gt;하면 더 깔끔하게 작성할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) 객체와 비객체를 비교하면 객체값이 ToPrimitive 강제변환 된다.&lt;/strong&gt;&lt;br&gt;
=&gt; 원시값으로 변환 : &lt;code class=&quot;language-text&quot;&gt;valueOf&lt;/code&gt;로 했을 때 원시값으로 나오면 그 원시값으로 하고, 아닐 경우 &lt;code class=&quot;language-text&quot;&gt;toString&lt;/code&gt;으로 변환됨.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5) ’&gt;‘와 ’&amp;#x3C;’ 비교일 경우, 두 피연산자에대해 ToPrimitive 강제변환을 실시한다.&lt;/strong&gt;&lt;br&gt;
=&gt; 1. 한쪽이라도 문자열값이면 각 문자를 알파벳순으로 비교한다.&lt;br&gt;
=&gt; 2. 한쪽이라도 문자열값이 아닌 경우에는 양쪽 모두 ToNumber로 강제변환한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[빈객체와 빈배열을 더한다면?]]></title><description><![CDATA[you don’t know JS 강제변환 파트에 다음과 같은 부분이 있다. 잘 알려진 강제변환 함정이 있다. [] + {} 대 {} + []. 연산 결과는 각각 ”object Object“와 0이다…]]></description><link>https://dwnyh.github.ioposts/TIL/array-plus-object/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/array-plus-object/</guid><pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;you don’t know JS 강제변환 파트에 다음과 같은 부분이 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;잘 알려진 강제변환 함정이 있다. [] + {} 대 {} + []. 연산 결과는 각각 ”[object Object]“와 0이다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4장쯤 읽으니 부연설명 없는 이러한 구문들에 대한 답답함이 찾는 즐거움으로 변하였다. 유명한 책이라 그런지 웬만한 내용은 스택오버플로우에 누군가가 질문을 달아놓았고, 답변도 풍부하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{} + []&lt;/strong&gt;는 왜 답이 0이 될까? &lt;a href=&quot;https://stackoverflow.com/questions/11939044/why-does-return-0-in-javascript&quot;&gt;스택오버플로우&lt;/a&gt;에 따르면, 자바스크립트 구문이 &lt;code class=&quot;language-text&quot;&gt;{&lt;/code&gt;로 시작하게 되면 객체리터럴이 아니라 block구문으로 본다고 한다. 그래서 앞의 &lt;code class=&quot;language-text&quot;&gt;{}&lt;/code&gt; 부분은 빈 코드블락으로 해석되게 되는 것이다. 빈 코드블락 뒤에 &lt;code class=&quot;language-text&quot;&gt;+[]&lt;/code&gt;부분이 남았는데 여기서 &lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;단항연산자&lt;/code&gt;(피연산자가 하나뿐인 연산자)로 처리되므로 피연산자를 숫자로 강제변환하게 된다.&lt;/p&gt;
&lt;p&gt;값을 숫자로 변환시키는 규칙에는 1) &lt;code class=&quot;language-text&quot;&gt;valueOf()&lt;/code&gt;를 쓸 수 있고 반환 값이 원시값이면 그대로 강제변환을 하고, 2) 그렇지 않을 경우에는 &lt;code class=&quot;language-text&quot;&gt;toString()&lt;/code&gt;을 이용해 강제변환을 하게 된다. 따라서 빈 배열과 같은 경우는 &lt;code class=&quot;language-text&quot;&gt;toString()&lt;/code&gt;이 적용되어 빈 문자열로 변환이 되며, 빈문자열은 falsy값이므로 0으로 변환되게 된다. 따라서 &lt;code class=&quot;language-text&quot;&gt;{} + [] = 0&lt;/code&gt;이 되게 되는 것이다.&lt;/p&gt;
&lt;p&gt;반면에 &lt;strong&gt;[] + {} = [object Object]&lt;/strong&gt;이다. &lt;code class=&quot;language-text&quot;&gt;+ 알고리즘(피연산자가 객체일 경우)&lt;/code&gt;에 따르면 &lt;strong&gt;한쪽 피연산자가 문자열이거나 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기&lt;/strong&gt;를 한다. 빈배열의 경우는 valueOf를 하면 빈 문자열이기 때문에 문자열 붙이기가 들어가고, 오른쪽 피연산자인 객체를 문자열화시키면 [object Object]이기 때문에 결과가 위와 같은 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫번째 책]]></title><link>https://dwnyh.github.ioposts/bookReview/array-plus-object/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/bookReview/array-plus-object/</guid><pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[첫번째 자바스크립트 지식]]></title><link>https://dwnyh.github.ioposts/javascript/array-plus-object/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/javascript/array-plus-object/</guid><pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[You Don't Know JS에 소개된 JSON.stringify()]]></title><description><![CDATA[‘You Don’t Know JS’ 두 번째 모임에서 진행된 3장 네이티브와 4장 강제변환의 소주제…]]></description><link>https://dwnyh.github.ioposts/TIL/json-stringify/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/json-stringify/</guid><pubDate>Sat, 09 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;‘You Don’t Know JS’ 두 번째 모임에서 진행된 3장 네이티브와 4장 강제변환의 소주제 2장까지는 실제로 코드를 작성하는 데에 유의미한 정보라기 보다는 아무 의심 없이 쓰고 있는 코드에 다시금 의문을 제기하는 내용들로 구성이 되어있었다. &lt;/p&gt;
&lt;p&gt;이를테면 문자열에 &lt;code class=&quot;language-text&quot;&gt;.length&lt;/code&gt;와 같은 메소드를 사용하는 것은 사실 문자열은 원시값으로 메소드가 없지만 자바스크립트가 원시값을 알아서 객체 래퍼로 감싸주기 때문에 String의 메소드들의 빌려쓸 수 있다는 것, 네이티브 생성자로 만든 문자열에(&lt;code class=&quot;language-text&quot;&gt;new String(&amp;#39;abc&amp;#39;)&lt;/code&gt;) 문자열 빈 값을 더하면(&lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&lt;/code&gt;) 결과값의 타입이 &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt;이 되는 것은 객체래퍼에 &lt;code class=&quot;language-text&quot;&gt;value of&lt;/code&gt;로 암식적인 언박싱이 일어난다는 것 등 암시적으로 일어나는 자바스크립트 변환에 대한 이야기를 접할 수 있었다.&lt;/p&gt;
&lt;p&gt;이런 이야기가 주된 반면, 이 책에서 설명한 &lt;code class=&quot;language-text&quot;&gt;JSON.stringify()&lt;/code&gt;부분은 실제 사용에도 유용해보여서 정리해 두려고 한다. 원래 JSON문자열화 할 대상만 하나의 인자로 받는줄 알았는데, 알고보니 세가지 파라미터 값을 받고 원하는대로 직렬화(다른 저장환경 등에서도 사용할 수 있는 형태로 바꿔주는 것)할 수 있다는 사실을 알게 되었다.&lt;/p&gt;
&lt;p&gt;먼저 JSON문자열화 할 대상 이후에 두번째 인자로 배열 또는 함수를 넣을 수 있다. 두번째인자가 배열이면 해당 배열에 들어있는 인자의 프로퍼티만 직렬화를 해주고, 두번째인자가 함수라면 이 함수는 인자로 key와 value값을 받아서 JSON문자열화를 할 때 어떻게 처리할지 정할 수 있다. &lt;/p&gt;
&lt;p&gt;예를 들면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;42&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    d&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 1) 두 번째 인자가 배열인 경우&lt;/span&gt;
  &lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;c&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// &quot;{&apos;b&apos;, 42, &apos;c&apos;: &apos;42&apos;}&quot;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 2) 두 번째 인자가 함수인 경우&lt;/span&gt;
  &lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;k&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; v&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;k &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;c&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; v&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;{&apos;b&apos;: 42, &apos;d&apos;: [1,2,3]}&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;세 번째 인자를 이용해서는 스페이스라고 하여 사람들이 쉽게 읽을 수 있도록 들여쓰기를 할 수 있다. 세 번째 인자로 들여쓰기를 할 빈 공간의 개수를 &lt;code class=&quot;language-text&quot;&gt;숫자&lt;/code&gt;로 지정하거나 &lt;code class=&quot;language-text&quot;&gt;문자열&lt;/code&gt;(ex. ’----‘와 같은것을 들여쓰기에 삽입하도록)을 지정해서 각 들여쓰기 수준에 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    b&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    c&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;42&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    d&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// &quot;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//    &quot;b&quot;: 42,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//    &quot;c&quot;: &apos;42&apos;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//    &quot;d&quot;: [&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//      1,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//      2,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//      3&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//    ]&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// }&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일하면서 실제 코드에서는 JSON.stringify를 사용해본 적이 없는데 사용하게 되면 꼭 써보아야겠다!🤓&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트에서의 1 나누기 0]]></title><description><![CDATA[토요일날 진행하는 you don’t know JS 독서 모임에서 1,2장 파트 이야기를 진행하다가 다음 예제에 대한 질문이 던져졌다. “왜 1 나누기…]]></description><link>https://dwnyh.github.ioposts/TIL/divided-by-infinity/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/divided-by-infinity/</guid><pubDate>Sat, 02 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;토요일날 진행하는 you don’t know JS 독서 모임에서 1,2장 파트 이야기를 진행하다가 다음 예제에 대한 질문이 던져졌다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Infinity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//-Infinity&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;“왜 1 나누기 0이 무한대인가요?”&lt;/strong&gt;
예제를 보면서 당연시 넘어갔던 부분에 대해 한 분이 질문을 해주셨는데 답을 할 수가 없어 구글링을 해보았다. 스택오버플로우의 여러 답변들과 책의 내용을 총집합해보면 이유는 다음과 같다. &lt;/p&gt;
&lt;p&gt;자바스크립트에서 숫자는 부동소수점으로 표기되므로 0은 0.000xxx을 나타내는데, 1을 0.000xxx와 같은 값으로 나눈다고 치면 0.000xxx보다 더 작고 소수점 뒤의 자리수가 더 긴 수로 나눠질텐데, 이렇게 표현할 수 있는 범위를 넘어선 숫자를 Infinity로 표기하므로 값이 &lt;code class=&quot;language-text&quot;&gt;Infinity&lt;/code&gt;가 나오는 것이다.&lt;/p&gt;
&lt;p&gt;이에 덧붙여 &lt;code class=&quot;language-text&quot;&gt;0/0&lt;/code&gt;은 1e-500/1e-600이 될 수도 있고 1e-600/1e-500 값이 될 수도 있는데 수치적으로 유의미 하지 않으므로 &lt;code class=&quot;language-text&quot;&gt;NaN&lt;/code&gt;을 리턴하는 것이라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27317517/make-division-by-zero-equal-to-zero&quot;&gt;출처: stackoverflow&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[문자열에 빌려쓸 수 있는/없는 배열 메서드]]></title><description><![CDATA[You don’t know JS책의 Chapter…]]></description><link>https://dwnyh.github.ioposts/TIL/usable-array-method-for-string/</link><guid isPermaLink="false">https://dwnyh.github.ioposts/TIL/usable-array-method-for-string/</guid><pubDate>Tue, 29 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;You don’t know JS책&lt;/strong&gt;의 &lt;strong&gt;Chapter 2 값&lt;/strong&gt;에 이런 내용이 있다.
&lt;code class=&quot;language-text&quot;&gt;문자열을 다룰 때 유용한 대부분의 배열 메서드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열메서드를 빌려 쓸 수는 있다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이와 함께 따라온 예제는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;foo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;join&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;
  a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;map&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;-&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;f-o-o&apos;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; d &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; v&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;FOO&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;텍스트로 봐서는 무슨말인지 감이 잘 안왔는데, 예제를 보니 조금 감이 왔다. 문자열에서 바로 배열메서드에 접근해 쓸 수는 없지만, 배열메서드에 문자열을 할당하는 방식으로는(빌려쓰는 방식으로는) 사용이 가능하다는 이야기로 이해했다.
그런데 이 뒤 바로 다음 글에 &lt;code class=&quot;language-text&quot;&gt;불행히도 문자열은 불변 값이라 바로 변경되지 않으므로 배열의 가변 메서드는 통하지 않고, 그래서 &amp;#39;빌려 쓰는 것&amp;#39; 또한 안된다&lt;/code&gt;라며 가변메서드를 빌려쓰는 다음 예제가 나온다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;foo&apos;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 불가능&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;??? 이해가 가지 않았다. 일단 1. 불변/가변메서드가 무엇인지 부터 이해가 안가고, 2. 왜 가변메서드는 빌려쓸 수 없는지도 이해가 안되었다.&lt;/p&gt;
&lt;p&gt;그래서 책을 먼저 읽은 지희한테 이 내용을 이야기했고, 논의끝에 지희가 1번에 대한 정의를 내려주었다. &lt;code class=&quot;language-text&quot;&gt;join&lt;/code&gt;메서드와 &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;으로는 원래 값이 변경되지 않은채 새로운 배열형태가 return되지만, reverse의 경우 원래의 값도 변경시키기 때문에 전자의 것은 불변, 후자의 것은 가변이라는 것이다. &lt;/p&gt;
&lt;p&gt;어느정도 궁금증은 해소되었으나 그래도 코드적으로 문자열에서 가변적인 메서드접근이 왜 안되는지 궁금했는데 지희가 이번엔 ECMAScript 명세를 관리하는 &lt;a href=&quot;https://tc39.es&quot;&gt;tc39사이트&lt;/a&gt;를 참고해보라고 알려주었다. 이곳에 &lt;code class=&quot;language-text&quot;&gt;join&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;reverse&lt;/code&gt;와 같은 Array 메소드들이 pseudo code 형태로 어떻게 구현되어있는지 설명되어있다.&lt;/p&gt;
&lt;p&gt;먼저 tc39사이트에 &lt;a href=&quot;https://tc39.es/ecma262/#sec-array.prototype.join&quot;&gt;Array.prototype.join&lt;/a&gt;가 pseudo code 형태로 작성된 것을 보면, 반복문을 돌면서 join하는 과정을 거치기 전에 빈 문자열을 할당하고 그 문자열에 join할 대상과 join 인자로 들어오는 seperator를 하나씩 결합키는 형태이다. 맨 처음 부분에서 join할 대상(ex. 문자열)을 Object화 시키고 join이 이루어질 때 index에 해당하는 property만 하나씩 잡아 새로운 문자열에 할당하기 때문에 원래 대상을 변화시키지 않아 가능한 것이다. &lt;/p&gt;
&lt;p&gt;두 번째로 &lt;a href=&quot;https://tc39.es/ecma262/#sec-array.prototype.map&quot;&gt;Array.prototype.map&lt;/a&gt;의 pseudo code를 살펴보면, 맨 처음에 map의 대상도 똑같이 Object화 시킨다. 그리고 나서 새 배열을 할당하고 현재 index에 해당하는 property에 접근해 mapping된 형태를 차례로 새 배열에 넣어주는 형태로 되기 때문에 원래 문자열을 변경시키지 않으므로 문자열에 map 메소드 사용이 가능하다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;strong&gt;가변적 메서드&lt;/strong&gt;인 &lt;a href=&quot;https://tc39.es/ecma262/#sec-array.prototype.reverse&quot;&gt;Array.prototype.reverse&lt;/a&gt;을 살펴보면, 이 역시 처음 reverse할 대상을 Object화시키는것으로 나온다. 그러나 위의 메서드들과 달리, Object화된 대상에 get만 이용하는 것이 아니라 set을 이용하여 하위 인덱스와 상위 인덱스에 해당하는 값을 직접 변경시켜준다. 배열은 가변값이기 때문에 위 속성이 가능하지만, 문자열은 불변값이기 때문에 불가능한 것이다.&lt;/p&gt;
&lt;p&gt;일년 전 자바스크립트의 원시값, 참조값 등의 개념을 배우면서 값에 대한 개념은 어느정도 안다고 생각했는데 이렇게 다시 조금만 응용해서 설명하면 아직 헷갈리는 부분이 있는 것 같다. 책을 보게 되어서 다행이라는 생각이 들었다 :)&lt;/p&gt;</content:encoded></item></channel></rss>